import { Entity } from "./Entity";
import { Scheduler } from "./Scheduler";
import { IObserver } from "../observer/IObserver";
import { Observer } from "./Observer";
import { Subject } from "../subject/Subject";
import { IDisposable } from "../Disposable/IDisposable";
import { DoStream } from "../stream/DoStream";
import { MapStream } from "../stream/MapStream";
import { MergeAllStream } from "../stream/MergeAllStream";
import { SkipUntilStream } from "../stream/SkipUntilStream";
import { TakeUntilStream } from "../stream/TakeUntilStream";
import { RepeatStream } from "../stream/RepeatStream";
import { IgnoreElementsStream } from "../stream/IgnoreElementsStream";
import { AnonymousStream } from "../stream/AnonymousStream";
export declare abstract class Stream extends Entity {
    scheduler: Scheduler;
    subscribeFunc: (observer: IObserver) => Function | void;
    constructor(subscribeFunc: any);
    abstract subscribe(arg1: Function | Observer | Subject, onError?: Function, onCompleted?: Function): IDisposable;
    buildStream(observer: IObserver): IDisposable;
    do(onNext?: Function, onError?: Function, onCompleted?: Function): DoStream;
    map(selector: Function): MapStream;
    flatMap(selector: Function): MergeAllStream;
    concatMap(selector: Function): any;
    mergeAll(): MergeAllStream;
    concatAll(): any;
    skipUntil(otherStream: Stream): SkipUntilStream;
    takeUntil(otherStream: Stream): TakeUntilStream;
    take(count?: number): AnonymousStream;
    takeLast(count?: number): AnonymousStream;
    takeWhile(predicate: (value: any, index: number, source: Stream) => boolean, thisArg?: this): AnonymousStream;
    lastOrDefault(defaultValue?: any): AnonymousStream;
    filter(predicate: (value: any) => boolean, thisArg?: this): any;
    filterWithState(predicate: (value: any) => boolean, thisArg?: this): any;
    concat(streamArr: Array<Stream>): any;
    concat(...otherStream: any[]): any;
    merge(maxConcurrent: number): any;
    merge(streamArr: Array<Stream>): any;
    merge(...otherStreams: any[]): any;
    repeat(count?: number): RepeatStream;
    ignoreElements(): IgnoreElementsStream;
    protected handleSubject(subject: any): boolean;
    private _isSubject(subject);
    private _setSubject(subject);
}
