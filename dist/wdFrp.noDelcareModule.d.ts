// Generated by dts-bundle v0.7.2
// Dependencies for this module:
//   ../../wonder-commonlib/dist/es2015/utils/JudgeUtils
//   ../../wonder-commonlib/dist/es2015/Collection

import { JudgeUtils as JudgeUtils$ } from "wonder-commonlib/dist/es2015/utils/JudgeUtils";
import { Collection } from "wonder-commonlib/dist/es2015/Collection";

import "./extend/root";
import "./global/init";

export class JudgeUtils extends JudgeUtils$ {
    static isPromise(obj: any): boolean;
    static isEqual(ob1: Entity, ob2: Entity): boolean;
    static isIObserver(i: IObserver): () => any;
}

export var fromNodeCallback: (func: Function, context?: any) => (...funcArgs: any[]) => AnonymousStream;
export var fromStream: (stream: any, finishEventName?: string) => AnonymousStream;
export var fromReadableStream: (stream: any) => AnonymousStream;
export var fromWritableStream: (stream: any) => AnonymousStream;
export var fromTransformStream: (stream: any) => AnonymousStream;

export abstract class Entity {
    static UID: number;
    uid: string;
    constructor(uidPre: string);
}

export class Main {
    static isTest: boolean;
}

export abstract class Observer extends Entity implements IObserver {
    isDisposed: boolean;
    protected onUserNext: Function;
    protected onUserError: Function;
    protected onUserCompleted: Function;
    constructor(observer: IObserver);
    constructor(onNext: Function, onError: Function, onCompleted: Function);
    next(value: any): any;
    error(error: any): void;
    completed(): void;
    dispose(): void;
    setDisposable(disposable: IDisposable): void;
    protected abstract onNext(value: any): any;
    protected abstract onError(error: any): any;
    protected abstract onCompleted(): any;
}

export class Scheduler {
    static create(...args: any[]): Scheduler;
    requestLoopId: any;
    publishRecursive(observer: IObserver, initial: any, action: Function): void;
    publishInterval(observer: IObserver, initial: any, interval: number, action: Function): number;
    publishIntervalRequest(observer: IObserver, action: Function): void;
    publishTimeout(observer: IObserver, time: number, action: Function): number;
}

export abstract class Stream extends Entity {
    scheduler: Scheduler;
    subscribeFunc: (observer: IObserver) => Function | void;
    constructor(subscribeFunc: any);
    abstract subscribe(arg1: Function | Observer | Subject, onError?: Function, onCompleted?: Function): IDisposable;
    buildStream(observer: IObserver): IDisposable;
    do(onNext?: Function, onError?: Function, onCompleted?: Function): any;
    map(selector: Function): any;
    flatMap(selector: Function): any;
    concatMap(selector: Function): any;
    mergeAll(): any;
    concatAll(): any;
    skipUntil(otherStream: Stream): any;
    takeUntil(otherStream: Stream): any;
    take(count?: number): any;
    takeLast(count?: number): any;
    takeWhile(predicate: (value: any, index: number, source: Stream) => boolean, thisArg?: this): any;
    lastOrDefault(defaultValue?: any): any;
    filter(predicate: (value: any) => boolean, thisArg?: this): any;
    filterWithState(predicate: (value: any) => boolean, thisArg?: this): any;
    concat(streamArr: Array<Stream>): any;
    concat(...otherStream: any[]): any;
    merge(maxConcurrent: number): any;
    merge(streamArr: Array<Stream>): any;
    merge(...otherStreams: any[]): any;
    repeat(count?: number): any;
    ignoreElements(): any;
    protected handleSubject(subject: any): boolean;
}

export function assert(cond: boolean, message?: string): void;
export function requireCheck(InFunc: any): (target: any, name: any, descriptor: any) => any;
export function ensure(OutFunc: any): (target: any, name: any, descriptor: any) => any;
export function requireGetter(InFunc: any): (target: any, name: any, descriptor: any) => any;
export function requireSetter(InFunc: any): (target: any, name: any, descriptor: any) => any;
export function ensureGetter(OutFunc: any): (target: any, name: any, descriptor: any) => any;
export function ensureSetter(OutFunc: any): (target: any, name: any, descriptor: any) => any;
export function invariant(func: any): (target: any) => void;

export class GroupDisposable extends Entity implements IDisposable {
    static create(disposable?: IDisposable): GroupDisposable;
    constructor(disposable?: IDisposable);
    add(disposable: IDisposable): this;
    remove(disposable: IDisposable): this;
    dispose(): void;
}

export interface IDisposable {
    dispose(): void;
}

export class InnerSubscription implements IDisposable {
    static create(subject: Subject | GeneratorSubject, observer: Observer): InnerSubscription;
    constructor(subject: Subject | GeneratorSubject, observer: Observer);
    dispose(): void;
}

export class InnerSubscriptionGroup implements IDisposable {
    static create(): InnerSubscriptionGroup;
    addChild(child: IDisposable): void;
    dispose(): void;
}

export class SingleDisposable extends Entity implements IDisposable {
    static create(disposeHandler?: Function): SingleDisposable;
    constructor(disposeHandler: Function);
    setDisposeHandler(handler: Function): void;
    dispose(): void;
}

export enum FilterState {
    TRIGGER = 0,
    ENTER = 1,
    LEAVE = 2,
}

export class Operator {
    static empty(): AnonymousStream;
    static createStream(subscribeFunc: any): AnonymousStream;
    static fromArray(array: Array<any>, scheduler?: Scheduler): FromArrayStream;
}
export var createStream: typeof Operator.createStream;
export var empty: typeof Operator.empty;
export var fromArray: typeof Operator.fromArray;
export var fromPromise: (promise: any, scheduler?: Scheduler) => FromPromiseStream;
export var fromEventPattern: (addHandler: Function, removeHandler: Function) => FromEventPatternStream;
export var interval: (interval: any, scheduler?: Scheduler) => IntervalStream;
export var intervalRequest: (scheduler?: Scheduler) => IntervalRequestStream;
export var timeout: (time: any, scheduler?: Scheduler) => TimeoutStream;
export var callFunc: (func: Function, context?: any) => AnonymousStream;
export var judge: (condition: Function, thenSource: Function, elseSource: Function) => any;
export var defer: (buildStreamFunc: Function) => DeferStream;
export var just: (returnValue: any) => AnonymousStream;

export var root: any;

export class AnonymousObserver extends Observer {
    static create(onNext: Function, onError: Function, onCompleted: Function): AnonymousObserver;
    protected onNext(value: any): void;
    protected onError(error: any): void;
    protected onCompleted(): void;
}

export class AutoDetachObserver extends Observer {
    static create(observer: IObserver): any;
    static create(onNext: Function, onError: Function, onCompleted: Function): any;
    dispose(): void;
    protected onNext(value: any): void;
    protected onError(error: any): void;
    protected onCompleted(): void;
}

export class ConcatObserver extends Observer {
    static create(currentObserver: IObserver, startNextStream: Function): ConcatObserver;
    protected currentObserver: any;
    constructor(currentObserver: IObserver, startNextStream: Function);
    protected onNext(value: any): void;
    protected onError(error: any): void;
    protected onCompleted(): void;
}

export class DoObserver extends Observer {
    static create(currentObserver: IObserver, prevObserver: IObserver): DoObserver;
    constructor(currentObserver: IObserver, prevObserver: IObserver);
    protected onNext(value: any): void;
    protected onError(error: any): void;
    protected onCompleted(): void;
}

export class FilterObserver extends Observer {
    static create(prevObserver: IObserver, predicate: (value: any, index?: number, source?: Stream) => boolean, source: Stream): FilterObserver;
    constructor(prevObserver: IObserver, predicate: (value: any) => boolean, source: Stream);
    protected prevObserver: IObserver;
    protected source: Stream;
    protected i: number;
    protected predicate: (value: any, index?: number, source?: Stream) => boolean;
    protected onNext(value: any): void;
    protected onError(error: any): void;
    protected onCompleted(): void;
}

export class FilterWithStateObserver extends FilterObserver {
    static create(prevObserver: IObserver, predicate: (value: any, index?: number, source?: Stream) => boolean, source: Stream): FilterWithStateObserver;
    protected onNext(value: any): void;
}

export class IgnoreElementsObserver extends Observer {
    static create(currentObserver: IObserver): IgnoreElementsObserver;
    constructor(currentObserver: IObserver);
    protected onNext(value: any): void;
    protected onError(error: any): void;
    protected onCompleted(): void;
}

export interface IObserver extends IDisposable {
    next(value: any): any;
    error(error: any): any;
    completed(): any;
}

export interface ISubjectObserver {
    addChild(observer: Observer): any;
    removeChild(observer: Observer): any;
}

export class MapObserver extends Observer {
    static create(currentObserver: IObserver, selector: Function): MapObserver;
    constructor(currentObserver: IObserver, selector: Function);
    protected onNext(value: any): void;
    protected onError(error: any): void;
    protected onCompleted(): void;
}

export class MergeAllObserver extends Observer {
    static create(currentObserver: IObserver, streamGroup: Collection<Stream>, groupDisposable: GroupDisposable): MergeAllObserver;
    constructor(currentObserver: IObserver, streamGroup: Collection<Stream>, groupDisposable: GroupDisposable);
    done: boolean;
    currentObserver: IObserver;
    protected onNext(innerSource: any): void;
    protected onError(error: any): void;
    protected onCompleted(): void;
}

export class MergeObserver extends Observer {
    static create(currentObserver: IObserver, maxConcurrent: number, streamGroup: Collection<Stream>, groupDisposable: GroupDisposable): MergeObserver;
    constructor(currentObserver: IObserver, maxConcurrent: number, streamGroup: Collection<Stream>, groupDisposable: GroupDisposable);
    done: boolean;
    currentObserver: IObserver;
    activeCount: number;
    q: Array<Stream>;
    handleSubscribe(innerSource: any): void;
    protected onNext(innerSource: any): void;
    protected onError(error: any): void;
    protected onCompleted(): void;
}

export class SkipUntilOtherObserver extends Observer {
    static create(prevObserver: IObserver, skipUntilStream: SkipUntilStream): SkipUntilOtherObserver;
    otherDisposable: IDisposable;
    constructor(prevObserver: IObserver, skipUntilStream: SkipUntilStream);
    protected onNext(value: any): void;
    protected onError(error: any): void;
    protected onCompleted(): void;
}

export class SkipUntilSourceObserver extends Observer {
    static create(prevObserver: IObserver, skipUntilStream: SkipUntilStream): SkipUntilSourceObserver;
    constructor(prevObserver: IObserver, skipUntilStream: SkipUntilStream);
    protected onNext(value: any): void;
    protected onError(error: any): void;
    protected onCompleted(): void;
}

export class SubjectObserver implements IObserver {
    observers: Collection<IObserver>;
    isEmpty(): boolean;
    next(value: any): void;
    error(error: any): void;
    completed(): void;
    addChild(observer: Observer): void;
    removeChild(observer: Observer): void;
    dispose(): void;
    setDisposable(disposable: IDisposable): void;
}

export class TakeUntilObserver extends Observer {
    static create(prevObserver: IObserver): TakeUntilObserver;
    constructor(prevObserver: IObserver);
    protected onNext(value: any): void;
    protected onError(error: any): void;
    protected onCompleted(): void;
}

export class AnonymousStream extends Stream {
    static create(subscribeFunc: Function): AnonymousStream;
    constructor(subscribeFunc: Function);
    buildStream(observer: IObserver): IDisposable;
    subscribe(subject: Subject): IDisposable;
    subscribe(observer: IObserver): IDisposable;
    subscribe(onNext: (value: any) => void): IDisposable;
    subscribe(onNext: (value: any) => void, onError: (e: any) => void): IDisposable;
    subscribe(onNext: (value: any) => void, onError: (e: any) => void, onComplete: () => void): IDisposable;
}

export abstract class BaseStream extends Stream {
    abstract subscribeCore(observer: IObserver): IDisposable;
    subscribe(arg1: Function | Observer | Subject, onError?: any, onCompleted?: any): IDisposable;
    buildStream(observer: IObserver): IDisposable;
}

export class ConcatStream extends BaseStream {
    static create(sources: Array<Stream>): ConcatStream;
    constructor(sources: Array<Stream>);
    subscribeCore(observer: IObserver): GroupDisposable;
}

export class DeferStream extends BaseStream {
    static create(buildStreamFunc: Function): DeferStream;
    constructor(buildStreamFunc: Function);
    subscribeCore(observer: IObserver): GroupDisposable;
}

export class DoStream extends BaseStream {
    static create(source: Stream, onNext?: Function, onError?: Function, onCompleted?: Function): DoStream;
    constructor(source: Stream, onNext: Function, onError: Function, onCompleted: Function);
    subscribeCore(observer: IObserver): IDisposable;
}

export class FilterStream extends BaseStream {
    static create(source: Stream, predicate: (value: any, index?: number, source?: Stream) => boolean, thisArg: any): FilterStream;
    constructor(source: Stream, predicate: (value: any, index?: number, source?: Stream) => boolean, thisArg: any);
    predicate: (value: any, index?: number, source?: Stream) => boolean;
    subscribeCore(observer: IObserver): IDisposable;
    internalFilter(predicate: (value: any, index?: number, source?: Stream) => boolean, thisArg: any): Stream;
    protected createObserver(observer: IObserver): Observer;
    protected createStreamForInternalFilter(source: Stream, innerPredicate: any, thisArg: any): Stream;
}

export class FilterWithStateStream extends FilterStream {
    static create(source: Stream, predicate: (value: any, index?: number, source?: Stream) => boolean, thisArg: any): FilterWithStateStream;
    protected createObserver(observer: IObserver): FilterWithStateObserver;
    protected createStreamForInternalFilter(source: Stream, innerPredicate: any, thisArg: any): Stream;
}

export class FromArrayStream extends BaseStream {
    static create(array: Array<any>, scheduler: Scheduler): FromArrayStream;
    constructor(array: Array<any>, scheduler: Scheduler);
    subscribeCore(observer: IObserver): SingleDisposable;
}

export class FromEventPatternStream extends BaseStream {
    static create(addHandler: Function, removeHandler: Function): FromEventPatternStream;
    constructor(addHandler: Function, removeHandler: Function);
    subscribeCore(observer: IObserver): SingleDisposable;
}

export class FromPromiseStream extends BaseStream {
    static create(promise: any, scheduler: Scheduler): FromPromiseStream;
    constructor(promise: any, scheduler: Scheduler);
    subscribeCore(observer: IObserver): SingleDisposable;
}

export class IgnoreElementsStream extends BaseStream {
    static create(source: Stream): IgnoreElementsStream;
    constructor(source: Stream);
    subscribeCore(observer: IObserver): IDisposable;
}

export class IntervalRequestStream extends BaseStream {
    static create(scheduler: Scheduler): IntervalRequestStream;
    constructor(scheduler: Scheduler);
    subscribeCore(observer: IObserver): SingleDisposable;
}

export class IntervalStream extends BaseStream {
    static create(interval: number, scheduler: Scheduler): IntervalStream;
    constructor(interval: number, scheduler: Scheduler);
    initWhenCreate(): void;
    subscribeCore(observer: IObserver): SingleDisposable;
}

export class MapStream extends BaseStream {
    static create(source: Stream, selector: Function): MapStream;
    constructor(source: Stream, selector: Function);
    subscribeCore(observer: IObserver): IDisposable;
}

export class MergeAllStream extends BaseStream {
    static create(source: Stream): MergeAllStream;
    constructor(source: Stream);
    subscribeCore(observer: IObserver): GroupDisposable;
}

export class MergeStream extends BaseStream {
    static create(source: Stream, maxConcurrent: number): MergeStream;
    constructor(source: Stream, maxConcurrent: number);
    subscribeCore(observer: IObserver): GroupDisposable;
}

export class RepeatStream extends BaseStream {
    static create(source: Stream, count: number): RepeatStream;
    constructor(source: Stream, count: number);
    subscribeCore(observer: IObserver): GroupDisposable;
}

export class SkipUntilStream extends BaseStream {
    static create(source: Stream, otherSteam: Stream): SkipUntilStream;
    isOpen: boolean;
    constructor(source: Stream, otherStream: Stream);
    subscribeCore(observer: IObserver): GroupDisposable;
}

export class TakeUntilStream extends BaseStream {
    static create(source: Stream, otherSteam: Stream): TakeUntilStream;
    constructor(source: Stream, otherStream: Stream);
    subscribeCore(observer: IObserver): GroupDisposable;
}

export class TimeoutStream extends BaseStream {
    static create(time: number, scheduler: Scheduler): TimeoutStream;
    constructor(time: number, scheduler: Scheduler);
    subscribeCore(observer: IObserver): SingleDisposable;
}

export class GeneratorSubject extends Entity implements IObserver {
    static create(): GeneratorSubject;
    isStart: boolean;
    constructor();
    observer: any;
    onBeforeNext(value: any): void;
    onAfterNext(value: any): void;
    onIsCompleted(value: any): boolean;
    onBeforeError(error: any): void;
    onAfterError(error: any): void;
    onBeforeCompleted(): void;
    onAfterCompleted(): void;
    subscribe(arg1?: Function | Observer, onError?: Function, onCompleted?: Function): IDisposable;
    next(value: any): void;
    error(error: any): void;
    completed(): void;
    toStream(): any;
    start(): void;
    stop(): void;
    remove(observer: Observer): void;
    dispose(): void;
}

export class Subject implements IObserver {
    static create(): Subject;
    source: Stream;
    subscribe(arg1?: Function | Observer, onError?: Function, onCompleted?: Function): IDisposable;
    next(value: any): void;
    error(error: any): void;
    completed(): void;
    start(): void;
    remove(observer: Observer): void;
    dispose(): void;
}

export enum ActionType {
    NEXT = 0,
    ERROR = 1,
    COMPLETED = 2,
}

export class MockObserver extends Observer {
    static create(scheduler: TestScheduler): MockObserver;
    messages: [Record];
    constructor(scheduler: TestScheduler);
    protected onNext(value: any): void;
    protected onError(error: any): void;
    protected onCompleted(): void;
    dispose(): void;
    clone(): MockObserver;
}

export class MockPromise {
    static create(scheduler: TestScheduler, messages: [Record]): MockPromise;
    constructor(scheduler: TestScheduler, messages: [Record]);
    then(successCb: Function, errorCb: Function, observer: IObserver): void;
}

export class Record {
    static create(time: number, value: any, actionType?: ActionType, comparer?: Function): Record;
    time: number;
    value: number;
    actionType: ActionType;
    constructor(time: any, value: any, actionType: ActionType, comparer: Function);
    equals(other: any): any;
}

export class TestScheduler extends Scheduler {
    static next(tick: any, value: any): Record;
    static error(tick: any, error: any): Record;
    static completed(tick: any): Record;
    static create(isReset?: boolean): TestScheduler;
    constructor(isReset: boolean);
    clock: number;
    setStreamMap(observer: IObserver, messages: [Record]): void;
    remove(observer: Observer): void;
    publishRecursive(observer: MockObserver, initial: any, recursiveFunc: Function): void;
    publishInterval(observer: IObserver, initial: any, interval: number, action: Function): number;
    publishIntervalRequest(observer: IObserver, action: Function): number;
    publishTimeout(observer: IObserver, time: number, action: Function): number;
    startWithTime(create: Function, subscribedTime: number, disposedTime: number): MockObserver;
    startWithSubscribe(create: any, subscribedTime?: number): MockObserver;
    startWithDispose(create: any, disposedTime?: number): MockObserver;
    publicAbsolute(time: any, handler: any): void;
    start(): void;
    createStream(args: any): TestStream;
    createObserver(): MockObserver;
    createResolvedPromise(time: number, value: any): MockPromise;
    createRejectPromise(time: number, error: any): MockPromise;
}

export class TestStream extends BaseStream {
    static create(messages: [Record], scheduler: TestScheduler): TestStream;
    scheduler: TestScheduler;
    constructor(messages: [Record], scheduler: TestScheduler);
    subscribeCore(observer: IObserver): SingleDisposable;
}

